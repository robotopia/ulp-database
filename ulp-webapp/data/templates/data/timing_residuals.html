{% extends "published/main.html" %}

{% load static %}

{% block body %}

<h1>{{ ulp }}</h1>

<label for="folding_period_select" class="form-label">Reset folding period to:</label>
<select id="folding_period_select" class="form-control" name="folding_period">
  {% for period in periods %}
  <option value="{{ period.quantity }}">{{ period.formatted_quantity_with_units }}</option>
  {% endfor %}
</select>

<label for="pepoch" class="form-label">PEPOCH:</label>
<input type="number" class="form-control" id="pepoch" value="{{ toas.0.mjd }}" onchange="replot()"/>

<label for="folding-period" class="form-label">Folding period:</label>
<input type="number" class="form-control" id="folding-period" value="{{ init_folding_period }}" onchange="replot()"/>

<input type="number" id="xmin" value="{{ plot_specs.xmin }}" onchange="replot()" hidden/>
<input type="number" id="xmax" value="{{ plot_specs.xmax }}" onchange="replot()" hidden/>
<input type="number" id="ymin" value="-0.5" onchange="replot()" hidden/>
<input type="number" id="ymax" value="0.5" onchange="replot()" hidden/>

<div id="residual-plot" style="height: 500px;"></div>

<script src="https://d3js.org/d3.v4.js"></script>
<script>

  // Get the data for the plot
  var plot_data = {{ toas | safe }};

  // Get the folding period and the PEPOCH
  var folding_period_element = document.getElementById("folding-period")
  var pepoch_element = document.getElementById("pepoch")

  var xmin_element = document.getElementById("xmin")
  var xmax_element = document.getElementById("xmax")
  var ymin_element = document.getElementById("ymin")
  var ymax_element = document.getElementById("ymax")

  // Function to calculate the pulse numbers and phases of TOAs
  function calc_pulse_phase(mjd, pepoch, P) {
    // mjd and pepoch should be in days,
    // P (the folding period) in seconds
    var pulse_phase = 86400*(mjd - pepoch)/P; // Dimensionless
    var pulse = Math.floor(pulse_phase)
    var phase = (pulse_phase + 0.5) % 1 - 0.5;
    return {pulse: pulse, phase: phase, pulse_phase: pulse_phase};
  }

  // set the dimensions and margins of the graph
  var parentDiv = document.getElementById("residual-plot");

  // append the svg object to the body of the page
  var svg = d3.select("#residual-plot").append("svg");

  // "g" is the main group containing all plotted elements
  var margin = {top: 50, right: 80, bottom: 50, left: 80};
  var g = svg.append('g')
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add axis labels
  xlabel = g.append("text")
    .attr("text-anchor", "middle")
    .text("MJD")
    .attr("fill", "var(--bs-body-color)");
  x2label = g.append("text")
    .attr("text-anchor", "middle")
    .text("Pulse number")
    .attr("fill", "var(--bs-body-color)");
  ylabel = g.append("text")
    .attr("transform", "rotate(-90)")
    .attr("text-anchor", "middle")
    .text("Residual (phase)")
    .attr("fill", "var(--bs-body-color)");
  y2label = g.append("text")
    .attr("transform", "rotate(-90)")
    .attr("text-anchor", "middle")
    .text("Residual (s)")
    .attr("fill", "var(--bs-body-color)");

  var xaxis = g.append("g");
  var yaxis = g.append("g");
  var x2axis = g.append("g");
  var y2axis = g.append("g");

  function plot_dataset(data, color) {

    // Get the folding period and the PEPOCH
    var folding_period = folding_period_element.value
    var pepoch = pepoch_element.value

    // Set the SVG width and height
    svg.attr("width", parentDiv.clientWidth)
      .attr("height", parentDiv.clientHeight)

    // Calculate the plot dimensions
    width = parentDiv.clientWidth - margin.left - margin.right;
    height = parentDiv.clientHeight - margin.top - margin.bottom;

    // Construct X axes
    x = d3.scaleLinear()
      .domain([xmin_element.value, xmax_element.value])
      .range([0, width]);

    x2 = d3.scaleLinear()
      .domain([calc_pulse_phase(xmin_element.value, pepoch, folding_period).pulse_phase,
               calc_pulse_phase(xmax_element.value, pepoch, folding_period).pulse_phase])
      .range([0, width]);

    xaxis.attr("transform", "translate(0," + height + ")");

    xlabel.attr("x", width/2)
      .attr("y", height + 0.75*margin.bottom)
    x2label.attr("x", width/2)
      .attr("y", -0.75*margin.top)

    xaxis.call(d3.axisBottom(x));
    xaxis.selectAll("text").style("fill", "var(--bs-body-color)");
    xaxis.selectAll("path").style("stroke", "var(--bs-body-color)");
    xaxis.selectAll("line").style("stroke", "var(--bs-body-color)");

    x2axis.call(d3.axisTop(x2));
    x2axis.selectAll("text").style("fill", "var(--bs-body-color)");
    x2axis.selectAll("path").style("stroke", "var(--bs-body-color)");
    x2axis.selectAll("line").style("stroke", "var(--bs-body-color)");

    // Construct Y axis
    y = d3.scaleLinear()
      .domain([ymin_element.value, ymax_element.value])
      .range([height, 0]);

    y2 = d3.scaleLinear()
      .domain([ymin_element.value*folding_period, ymax_element.value*folding_period])
      .range([height, 0]);

    y2axis.attr("transform", "translate(" + width + ",0)");

    ylabel.attr("y", -0.5*margin.left)
      .attr("x", -height/2)
    y2label.attr("y", width + 0.75*margin.right)
      .attr("x", -height/2)

    yaxis.call(d3.axisLeft(y));
    yaxis.selectAll("text").style("fill", "var(--bs-body-color)");
    yaxis.selectAll("path").style("stroke", "var(--bs-body-color)");
    yaxis.selectAll("line").style("stroke", "var(--bs-body-color)");

    y2axis.call(d3.axisRight(y2));
    y2axis.selectAll("text").style("fill", "var(--bs-body-color)");
    y2axis.selectAll("path").style("stroke", "var(--bs-body-color)");
    y2axis.selectAll("line").style("stroke", "var(--bs-body-color)");

    // Remove previous points
    g.selectAll('.data').remove();

    // Add vertical dashed line for PEPOCH
    g.append("path")
      .attr("d", "M " + x2(0) + ",0 l 0," + height)
      .style("stroke", "#aaee1180")
      .style("stroke-width", "2")
      .style("stroke-dasharray", "7")
      .classed("data", true);

    // Add dashed line for click-n-drag for changing period
    period_path = g.append("path")
      .style("stroke", "#aaee1180")
      .style("stroke-width", "2")
      .style("stroke-dasharray", "7")
      .style("stroke-opacity", "0")
      .classed("data", true);

    // Add points
    g.selectAll(".dot")
      .data(data)
      .enter()
      .append("circle")
      .attr("cx", function (toa) { return x2(calc_pulse_phase(toa.mjd, pepoch, folding_period).pulse); })
      .attr("cy", function (toa) { return y(calc_pulse_phase(toa.mjd, pepoch, folding_period).phase); })
      .attr("r", 3)
      .style("fill", color)
      .classed("data", true);

    // Add error bars
    g.selectAll(".err")
      .data(data)
      .enter()
      .append("path")
      .attr("d", function (toa) {
        pulse_phase_lo = calc_pulse_phase(toa.mjd - toa.mjd_err, pepoch, folding_period);
        pulse_phase_hi = calc_pulse_phase(toa.mjd + toa.mjd_err, pepoch, folding_period);

        pulse = pulse_phase_lo.pulse;
        phase_lo = pulse_phase_lo.phase;
        phase_hi = pulse_phase_hi.phase;

        let xpos = x2(pulse);

        return " M " + xpos + "," + y(phase_lo) +
               " L " + xpos + "," + y(phase_hi);
      })
      .style("stroke", color)
      .style("stroke-width", "2")
      .classed("data", true);

  }

  function replot() {
    plot_dataset(plot_data, "#d090f8");
  }

  // Zoom on mouse wheel
  svg.on("wheel", function(d) {
    xmin = parseFloat(xmin_element.value);
    xmax = parseFloat(xmax_element.value);
    ymin = parseFloat(ymin_element.value);
    ymax = parseFloat(ymax_element.value);

    m = d3.mouse(this);
    xpos = x.invert(m[0] - margin.left);
    ypos = y.invert(m[1] - margin.top);

    scale_factor = d3.event.wheelDelta < 0 ? 0.05 : -0.05;

    if (xpos > xmin && xpos < xmax) { // if mouse is not over the y-axis itself (if it were, we leave x-zoom untouched)
      xmin -= scale_factor*(xpos - xmin);
      xmax += scale_factor*(xmax - xpos);
      xmin_element.value = xmin;
      xmax_element.value = xmax;
    }

    if (ypos > ymin && ypos < ymax) { // if mouse is not over the x-axis itself (if it were, we leave y-zoom untouched)
      ymin -= scale_factor*(ypos - ymin);
      ymax += scale_factor*(ymax - ypos);
      ymin_element.value = ymin;
      ymax_element.value = ymax;
    }

    replot();
  });

  // A handy function for plotting the period path
  function myLine(svg, path, pos) {

    // Draw the svg line from the origin to the clicked point
    // Everything here in "g" coords
    pos[0] -= margin.left; // (Now converted to "g" coords)
    pos[1] -= margin.top;
    let origpos = [x2(0), y(0)];
    let slope = (pos[1] - origpos[1]) / (pos[0] - origpos[0]);
    let yintercept = pos[1] - slope*pos[0];

    // Draw the path connecting the clicked point and the origin
    period_path
      .attr("d", "M 0," + yintercept + " L " + width + "," + (slope*width + yintercept))
      .style("stroke-opacity", "0.5");

  }

  // Change period on mouse drag
  mousedown = false;
  svg.on("mousedown", function() {
    // Record in global variable the fact that the mouse button is down
    mousedown = true;
    ref_factor = null;
  });

  svg.on("mousemove", function() {
    if (mousedown) {
      d3.event.preventDefault();

      // Draw the svg line from the origin to the clicked point
      let movepos = d3.mouse(this);

      // Record for later use the world coords of the clicked event, as well as the folding period
      let mjd = x.invert(movepos[0] - margin.left) - pepoch_element.value; // world coords of click pos
      let res = y2.invert(movepos[1] - margin.top);                       // world coords of click pos
      factor = res / (mjd*86400);

      if (ref_factor !== null) {
        folding_period_element.value *= (1 - (factor - ref_factor));
      }
      ref_factor = factor;

      replot();
      myLine(svg, period_path, movepos);
    }
  });

  svg.on("mouseup", function() {
    mousedown = false;

    period_path
      .style("stroke-opacity", "0.0")

  });

  // Plot once to get started
  replot();

</script>

{% endblock %}
